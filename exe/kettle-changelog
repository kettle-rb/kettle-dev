#!/usr/bin/env ruby
# frozen_string_literal: true

# vim: set syntax=ruby

# kettle-changelog: Generate a CHANGELOG.md entry for the current VERSION.
# - Reads VERSION from lib/**/version.rb (must be unique across files)
# - Moves entries from the "Unreleased" section into a new versioned section
# - Prepends 4 heading lines:
#   - TAG
#   - COVERAGE (line coverage)
#   - BRANCH COVERAGE (branch coverage)
#   - percent documented (parsed from `bin/yard` output)
# - Updates bottom link references to GitHub style, converts any existing
#   GitLab links to GitHub links, and appends the new [X.Y.Z] and [X.Y.Zt] links.
#
# Notes:
# - Expects a JSON coverage report at coverage/coverage.json. If missing,
#   it will instruct you to run: K_SOUP_COV_FORMATTERS="json" bin/rspec
# - Expects bin/yard to be available via Bundler.

$stdout.sync = true

# Depending library or project must be using bundler
require "bundler/setup"

script_basename = File.basename(__FILE__)

begin
  # Standard library
  require "json"
  require "time"
  require "open3"
  require "shellwords"

  # This library
  require "kettle/dev"
  puts "== #{script_basename} v#{Kettle::Dev::Version::VERSION} =="
rescue LoadError => e
  warn("#{script_basename}: could not load dependency: #{e.class}: #{e.message}")
  warn("Hint: Ensure the host project has kettle-dev as a dependency and run bundle install.")
  exit(1)
end

begin
  if ARGV.include?("-h") || ARGV.include?("--help")
    puts <<~USAGE
      Usage: kettle-changelog

      Generates a new CHANGELOG.md entry for the current version detected from lib/**/version.rb.
      Moves entries from [Unreleased] into the new section, adds coverage and documentation stats,
      and updates bottom link references to GitHub style, adding new compare/tag links.

      Prerequisites:
        - coverage/coverage.json present (run: K_SOUP_COV_FORMATTERS="json" bin/rspec)
        - yard installed and available via bin/yard
    USAGE
    exit(0)
  end
end

begin
  Kettle::Dev::ChangelogCLI.new.run
rescue LoadError => e
  warn("#{script_basename}: could not load dependency: #{e.class}: #{e.message}")
  warn(e.backtrace.join("\n")) if ENV["DEBUG"]
  exit(1)
rescue SystemExit => e
  # Preserve exit status, but ensure at least a newline so shells don't show an empty line only.
  warn("#{script_basename}: exited (status=#{e.status}, msg=#{e.message})") if e.status != 0
  raise
rescue StandardError => e
  warn("#{script_basename}: unexpected error: #{e.class}: #{e.message}")
  warn(e.backtrace.join("\n"))
  exit(1)
end
