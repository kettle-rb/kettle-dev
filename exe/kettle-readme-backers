#!/usr/bin/env ruby
# frozen_string_literal: true

# Updates README.md backers and sponsors sections using data from Open Collective
# backers.json and sponsors.json for the configured handle.
#
# Backers (individuals) section markers supported (first match wins):
#   <!-- OPENCOLLECTIVE:START --> ... <!-- OPENCOLLECTIVE:END -->
#   <!-- OPENCOLLECTIVE-INDIVIDUALS:START --> ... <!-- OPENCOLLECTIVE-INDIVIDUALS:END -->
# Sponsors (organizations) section markers:
#   <!-- OPENCOLLECTIVE-ORGANIZATIONS:START --> ... <!-- OPENCOLLECTIVE-ORGANIZATIONS:END -->
#
# Handle resolution order:
#   1. ENV["OPENCOLLECTIVE_HANDLE"] if present
#   2. .opencollective.yml's `collective:` key in project root if present
#   3. Abort with error
#
# Usage:
#   OPENCOLLECTIVE_HANDLE=kettle-rb exe/kettle-readme-backers
#   # or ensure .opencollective.yml exists with collective: "kettle-rb"

require "rubygems"
require "bundler/setup"

require "yaml"
require "json"
require "uri"
require "net/http"
require "set"

DEFAULT_AVATAR = "https://opencollective.com/static/images/default-avatar.png"
README_PATH = File.expand_path("../README.md", __dir__)
OC_YML_PATH = File.expand_path("../.opencollective.yml", __dir__)
GENERIC_START_TAG = "<!-- OPENCOLLECTIVE:START -->"
GENERIC_END_TAG = "<!-- OPENCOLLECTIVE:END -->"
INDIVIDUALS_START_TAG = "<!-- OPENCOLLECTIVE-INDIVIDUALS:START -->"
INDIVIDUALS_END_TAG = "<!-- OPENCOLLECTIVE-INDIVIDUALS:END -->"
ORGS_START_TAG = "<!-- OPENCOLLECTIVE-ORGANIZATIONS:START -->"
ORGS_END_TAG = "<!-- OPENCOLLECTIVE-ORGANIZATIONS:END -->"

module Kettle
  module Dev
    class ReadmeBackers
      Backer = Struct.new(:name, :image, :website, :profile, keyword_init: true)

      def initialize(handle: nil, readme_path: README_PATH)
        @handle = handle || resolve_handle
        @readme_path = readme_path
      end

      def run!
        readme = File.read(@readme_path)

        # Identify previous entries for diffing/mentions
        b_start, b_end = detect_backer_tags(readme)
        prev_backer_identities = extract_section_identities(readme, b_start, b_end)
        s_start_prev, s_end_prev = detect_sponsor_tags(readme)
        prev_sponsor_identities = extract_section_identities(readme, s_start_prev, s_end_prev)

        # Backers (individuals)
        backers = fetch_members("backers.json")
        backers_md = generate_markdown(backers, empty_message: "No backers yet. Be the first!", default_name: "Backer")
        updated = replace_between_tags(readme, b_start, b_end, backers_md)
        case updated
        when :not_found
          # Do not exit yet; we may still update sponsors.
          updated_readme = readme
          backers_changed = false
          new_backers = []
        when :no_change
          updated_readme = readme
          backers_changed = false
          new_backers = []
        else
          updated_readme = updated
          backers_changed = true
          new_backers = compute_new_members(prev_backer_identities, backers)
        end

        # Sponsors (organizations)
        sponsors = fetch_members("sponsors.json")
        sponsors_md = generate_markdown(sponsors, empty_message: "No sponsors yet. Be the first!", default_name: "Sponsor")
        s_start, s_end = detect_sponsor_tags(updated_readme)
        updated2 = replace_between_tags(updated_readme, s_start, s_end, sponsors_md)
        case updated2
        when :not_found
          sponsors_changed = false
          final = updated_readme
          new_sponsors = []
        when :no_change
          sponsors_changed = false
          final = updated_readme
          new_sponsors = []
        else
          sponsors_changed = true
          final = updated2
          new_sponsors = compute_new_members(prev_sponsor_identities, sponsors)
        end

        if !backers_changed && !sponsors_changed
          if b_start == :not_found && s_start == :not_found
            warn("No recognized Open Collective tags found in #{@readme_path}. Expected one or more of: " \
              "#{GENERIC_START_TAG}/#{GENERIC_END_TAG}, #{INDIVIDUALS_START_TAG}/#{INDIVIDUALS_END_TAG}, #{ORGS_START_TAG}/#{ORGS_END_TAG}.")
            exit(2)
          end
          puts "No changes to backers or sponsors sections in #{@readme_path}."
          return
        end

        File.write(@readme_path, final)
        msgs = []
        msgs << "backers" if backers_changed
        msgs << "sponsors" if sponsors_changed
        puts "Updated #{msgs.join(" and ")} section#{{true => "s", false => ""}[msgs.size > 1]} in #{@readme_path}."

        # Compose and perform commit with mentions if in a git repo
        perform_git_commit(new_backers, new_sponsors) if git_repo? && (backers_changed || sponsors_changed)
      end

      private

      def resolve_handle
        env = ENV["OPENCOLLECTIVE_HANDLE"]
        return env unless env.nil? || env.strip.empty?
        if File.file?(OC_YML_PATH)
          yml = YAML.safe_load(File.read(OC_YML_PATH))
          handle = yml.is_a?(Hash) ? yml["collective"] || yml[:collective] : nil
          return handle.to_s unless handle.nil? || handle.to_s.strip.empty?
        end
        abort("ERROR: Open Collective handle not provided. Set OPENCOLLECTIVE_HANDLE or add 'collective: <handle>' to .opencollective.yml.")
      end

      def fetch_members(path)
        url = URI("https://opencollective.com/#{@handle}/#{path}")
        response = Net::HTTP.start(url.host, url.port, use_ssl: url.scheme == "https") do |conn|
          conn.read_timeout = 10
          conn.open_timeout = 5
          req = Net::HTTP::Get.new(url)
          req["User-Agent"] = "kettle-dev/README-backers"
          conn.request(req)
        end
        return [] unless response.is_a?(Net::HTTPSuccess)
        parsed = JSON.parse(response.body)
        Array(parsed).map do |h|
          Backer.new(
            name: h["name"],
            image: (h["image"].to_s.strip.empty? ? nil : h["image"]),
            website: (h["website"].to_s.strip.empty? ? nil : h["website"]),
            profile: (h["profile"].to_s.strip.empty? ? nil : h["profile"]),
          )
        end
      rescue JSON::ParserError => e
        warn("Error parsing #{path} JSON: #{e.message}")
        []
      rescue StandardError => e
        warn("Error fetching #{path}: #{e.class}: #{e.message}")
        []
      end

      def generate_markdown(members, empty_message:, default_name:)
        return empty_message if members.nil? || members.empty?
        members.map do |m|
          image_url = m.image || DEFAULT_AVATAR
          link = m.website || m.profile || "#"
          name = (m.name && !m.name.strip.empty?) ? m.name : default_name
          "[![#{escape_text(name)}](#{image_url})](#{link})"
        end.join(" ")
      end

      def replace_between_tags(content, start_tag, end_tag, new_content)
        return :not_found if start_tag == :not_found || end_tag == :not_found
        start_index = content.index(start_tag)
        end_index = content.index(end_tag)
        return :not_found if start_index.nil? || end_index.nil? || end_index < start_index
        before = content[0..start_index + start_tag.length - 1]
        after = content[end_index..-1]
        replacement = "#{start_tag}\n#{new_content}\n#{end_tag}"
        current_block = content[start_index..end_index + end_tag.length - 1]
        return :no_change if current_block == replacement
        trailing = after[end_tag.length..-1] || ""
        "#{before}\n#{new_content}\n#{end_tag}#{trailing}"
      end

      def detect_backer_tags(content)
        if content.include?(GENERIC_START_TAG) && content.include?(GENERIC_END_TAG)
          [GENERIC_START_TAG, GENERIC_END_TAG]
        elsif content.include?(INDIVIDUALS_START_TAG) && content.include?(INDIVIDUALS_END_TAG)
          [INDIVIDUALS_START_TAG, INDIVIDUALS_END_TAG]
        else
          [:not_found, :not_found]
        end
      end

      def detect_sponsor_tags(content)
        if content.include?(ORGS_START_TAG) && content.include?(ORGS_END_TAG)
          [ORGS_START_TAG, ORGS_END_TAG]
        else
          [:not_found, :not_found]
        end
      end

      # Extract identity tokens from the current README section between start/end tags
      # Identity priority used for comparison:
      #   href (profile/website URL) downcased, else alt text (name) downcased
      def extract_section_identities(content, start_tag, end_tag)
        return Set.new unless start_tag && end_tag && start_tag != :not_found && end_tag != :not_found
        start_index = content.index(start_tag)
        end_index = content.index(end_tag)
        return Set.new if start_index.nil? || end_index.nil? || end_index < start_index
        block = content[(start_index + start_tag.length)...end_index]
        identities = Set.new
        # Match patterns like: [![Alt](image_url)](link_url)
        block.to_s.scan(/\[!\[[^\]]*\]\([^\)]*\)\]\(([^\)]+)\)/) do |m|
          href = (m[0] || "").strip
          identities << href.downcase unless href.empty?
        end
        # Also capture alt texts in case links are missing
        block.to_s.scan(/\[!\[([^\]]*)\]\([^\)]*\)\]\([^\)]*\)/) do |m|
          alt = (m[0] || "").strip
          identities << alt.downcase unless alt.empty?
        end
        identities
      end

      def compute_new_members(previous_identities, members)
        prev = previous_identities || Set.new
        members.select do |m|
          id = identity_for_member(m)
          !prev.include?(id)
        end
      end

      def identity_for_member(m)
        if m.profile && !m.profile.strip.empty?
          m.profile.strip.downcase
        elsif m.website && !m.website.strip.empty?
          m.website.strip.downcase
        elsif m.name && !m.name.strip.empty?
          m.name.strip.downcase
        else
          ""
        end
      end

      def mention_for_member(m, default_name: "Member")
        handle = github_handle_from_urls(m.profile, m.website)
        return "@#{handle}" if handle
        name = (m.name && !m.name.strip.empty?) ? m.name.strip : default_name
        name
      end

      def github_handle_from_urls(*urls)
        urls.compact.each do |u|
          begin
            uri = URI.parse(u)
          rescue URI::InvalidURIError
            next
          end
          next unless uri&.host&.downcase&.end_with?("github.com")
          path = (uri.path || "").sub(%r{^/}, "").sub(%r{/$}, "")
          next if path.empty?
          parts = path.split("/")
          # github.com/sponsors/<handle> or github.com/<handle>/...
          candidate = if parts[0].downcase == "sponsors" && parts[1]
            parts[1]
          else
            parts[0]
          end
          candidate = candidate.gsub(%r{[^a-zA-Z0-9-]}, "")
          return candidate unless candidate.empty?
        end
        nil
      end

      def perform_git_commit(new_backers, new_sponsors)
        backer_mentions = new_backers.map { |m| mention_for_member(m, default_name: "Backer") }.uniq
        sponsor_mentions = new_sponsors.map { |m| mention_for_member(m, default_name: "Subscriber") }.uniq
        title = commit_subject
        lines = [title]
        lines << ""
        lines << "Backers: #{backer_mentions.join(", ")}" unless backer_mentions.empty?
        lines << "Subscribers: #{sponsor_mentions.join(", ")}" unless sponsor_mentions.empty?
        message = lines.join("\n")
        # Stage and commit README.md
        system("git", "add", @readme_path)
        # Only commit if README is staged/changed
        if system("git", "diff", "--cached", "--quiet")
          # nothing staged; skip commit
          return
        end
        system("git", "commit", "-m", message)
      end

      def commit_subject
        env = ENV["KETTLE_README_BACKERS_COMMIT_SUBJECT"].to_s
        return env unless env.strip.empty?
        # Fallback to .opencollective.yml key: readme-backers-commit-subject
        if File.file?(OC_YML_PATH)
          begin
            yml = YAML.safe_load(File.read(OC_YML_PATH))
            if yml.is_a?(Hash)
              from_yml = yml["readme-backers-commit-subject"] || yml[:"readme-backers-commit-subject"]
              from_yml = from_yml.to_s if from_yml
              return from_yml unless from_yml.nil? || from_yml.strip.empty?
            end
          rescue StandardError
            # ignore yaml read errors and fall back to default
          end
        end
        "ðŸ’¸ Thanks ðŸ™ to our new backers ðŸŽ’ and subscribers ðŸ“œ"
      end

      def git_repo?
        system("git", "rev-parse", "--is-inside-work-tree", out: File::NULL, err: File::NULL)
      end

      def escape_text(text)
        text.gsub("[", "\\[").gsub("]", "\\]")
      end
    end
  end
end

if __FILE__ == $PROGRAM_NAME
  Kettle::Dev::ReadmeBackers.new.run!
end
