#!/usr/bin/env ruby
# frozen_string_literal: true

# kettle-release: Automate release steps from CONTRIBUTING.md
# - Runs sanity checks
# - Ensures version/changelog updated (with confirmation)
# - Commits and pushes a release prep commit
# - Ensures on trunk, up-to-date
# - Exports SOURCE_DATE_EPOCH for reproducible checksums
# - Runs `bundle exec rake build` (expects PEM password unless SKIP_GEM_SIGNING)
#   - If signing not skipped and no public cert in certs/<user>.pem, aborts with guidance
# - Runs bin/gem_checksums
# - Runs `bundle exec rake release` (expects PEM password and RubyGems MFA OTP)

ENV["BUNDLE_GEMFILE"] ||= File.expand_path("../Gemfile", __dir__)

require "rubygems"
require "bundler/setup"

require "open3"
require "shellwords"
require "time"
require "fileutils"
require "net/http"
require "json"
require "uri"
require "kettle/dev/ci_helpers"
require "ruby-progressbar"

module Kettle
  module Dev
    class ReleaseCLI
      def initialize
        @root = File.expand_path("..", __dir__)
      end

      def run
        puts "== kettle-release =="

        run_cmd!("bin/setup")
        run_cmd!("bin/rake")

        version = detect_version
        puts "Detected version: #{version.inspect}"
        puts "Have you updated lib/**/version.rb and CHANGELOG.md for v#{version}? [y/N]"
        print("> ")
        ans = $stdin.gets&.strip
        abort("Aborted: please update version.rb and CHANGELOG.md, then re-run.") unless ans&.downcase&.start_with?("y")

        # Re-run checks (and refresh Gemfile.lock)
        run_cmd!("bin/setup")
        run_cmd!("bin/rake")

        # Update Appraisal gemfiles if Appraisals file is present
        appraisals_path = File.join(@root, "Appraisals")
        if File.file?(appraisals_path)
          puts "Appraisals detected at #{appraisals_path}. Running: bin/rake appraisal:update"
          run_cmd!("bin/rake appraisal:update")
        else
          puts "No Appraisals file found; skipping appraisal:update"
        end

        ensure_git_user!
        commit_release_prep!(version)

        trunk = detect_trunk_branch
        feature = current_branch
        puts "Trunk branch detected: #{trunk}"
        ensure_trunk_synced_before_push!(trunk, feature)

        push!

        # After pushing, ensure the CI workflows for this project are passing
        monitor_workflows_after_push!

        # If all workflows are passing, merge the feature branch into trunk and push trunk
        merge_feature_into_trunk_and_push!(trunk, feature)

        # Ensure we are on trunk for the remaining steps
        checkout!(trunk)
        pull!(trunk)

        export_source_date_epoch!

        ensure_signing_setup_or_skip!
        # Build: expect PEM password prompt unless SKIP_GEM_SIGNING
        puts "Running build (you may be prompted for the signing key password)..."
        run_cmd!("bundle exec rake build")

        # Checksums (commits, but does not push)
        run_cmd!("bin/gem_checksums")

        # Release: expect PEM password + RubyGems MFA OTP
        puts "Running release (you may be prompted for signing key password and RubyGems MFA OTP)..."
        run_cmd!("bundle exec rake release")

        puts "\nRelease complete. Don't forget to push the checksums commit if needed."
      end

      private

      # Monitor GitHub Actions workflows discovered by ci:act logic.
      # Checks one workflow per second in a round-robin loop until all pass, or any fails.
      def monitor_workflows_after_push!
        root = Kettle::Dev::CIHelpers.project_root
        workflows = Kettle::Dev::CIHelpers.workflows_list(root)
        if workflows.empty?
          puts "No workflows detected under .github/workflows; skipping CI checks."
          return
        end

        owner, repo = Kettle::Dev::CIHelpers.repo_info
        branch = Kettle::Dev::CIHelpers.current_branch
        unless owner && repo && branch
          puts "Unable to determine repository or branch; skipping CI checks."
          return
        end

        total = workflows.size
        passed = {}
        idx = 0
        puts "Ensuring CI workflows pass on branch #{branch} (#{owner}/#{repo})"
        pbar = ProgressBar.create(title: "CI", total: total, format: "%t %b %c/%C", length: 30)

        loop do
          wf = workflows[idx]
          run = Kettle::Dev::CIHelpers.latest_run(owner: owner, repo: repo, workflow_file: wf, branch: branch)
          if run
            if Kettle::Dev::CIHelpers.success?(run)
              unless passed[wf]
                passed[wf] = true
                pbar.increment
              end
            elsif Kettle::Dev::CIHelpers.failed?(run)
              # Fail fast with link to the failed run
              puts
              url = run["html_url"] || "https://github.com/#{owner}/#{repo}/actions/workflows/#{wf}"
              abort("Workflow failed: #{wf} -> #{url}")
            end
          end

          break if passed.size == total

          idx = (idx + 1) % total
          sleep(1)
        end
        pbar.finish unless pbar.finished?
        puts "\nAll workflows passing (#{passed.size}/#{total})."
      end

      def run_cmd!(cmd)
        puts "$ #{cmd}"
        success = system(cmd)
        abort("Command failed: #{cmd}") unless success
      end

      def git_output(args)
        out, status = Open3.capture2("git", *args)
        [out.strip, status.success?]
      end

      def check_git_clean!
        out, ok = git_output(["status", "--porcelain"])
        abort("Git working tree is not clean. Commit/stash changes before releasing.\n\n#{out}") unless ok && out.empty?
      end

      def ensure_git_user!
        name, ok1 = git_output(["config", "user.name"])
        email, ok2 = git_output(["config", "user.email"])
        abort("Git user.name or user.email not configured.") unless ok1 && ok2 && !name.empty? && !email.empty?
      end

      def detect_version
        # Look for lib/**/version.rb and extract VERSION constant string
        candidates = Dir[File.join(@root, "lib", "**", "version.rb")]
        abort("Could not find version.rb under lib/**.") if candidates.empty?
        path = candidates.min
        content = File.read(path)
        m = content.match(/VERSION\s*=\s*(["'])([^"']+)\1/)
        abort("VERSION constant not found in #{path}.") unless m
        m[2]
      end

      def commit_release_prep!(version)
        msg = "ðŸ”– Prepare release v#{version}"
        # Only commit if there are changes (version/changelog)
        out, _ = git_output(["status", "--porcelain"])
        if out.empty?
          puts "No changes to commit for release prep (continuing)."
        else
          run_cmd!(%(git commit -am #{Shellwords.escape(msg)}))
        end
      end

      def push!
        puts "$ git push"
        success = system("git push")
        unless success
          warn("Normal push failed; retrying with force push...")
          run_cmd!("git push -f")
        end
      end

      def detect_trunk_branch
        out, ok = git_output(["remote", "show", "origin"])
        abort("Failed to get origin remote info.") unless ok
        m = out.lines.find { |l| l.include?("HEAD branch") }
        abort("Unable to detect trunk branch from origin.") unless m
        m.split.last
      end

      def checkout!(branch)
        run_cmd!("git checkout #{Shellwords.escape(branch)}")
      end

      def pull!(branch)
        run_cmd!("git pull origin #{Shellwords.escape(branch)}")
      end

      def current_branch
        out, ok = git_output(["rev-parse", "--abbrev-ref", "HEAD"])
        ok ? out : nil
      end

      def list_remotes
        out, ok = git_output(["remote"])
        ok ? out.split(/\s+/).reject(&:empty?) : []
      end

      def has_remote?(name)
        list_remotes.include?(name)
      end

      def remote_branch_exists?(remote, branch)
        _out, ok = git_output(["show-ref", "--verify", "--quiet", "refs/remotes/#{remote}/#{branch}"])
        ok
      end

      def ahead_behind_counts(local_ref, remote_ref)
        out, ok = git_output(["rev-list", "--left-right", "--count", "#{local_ref}...#{remote_ref}"])
        return [0, 0] unless ok && !out.empty?
        parts = out.split
        left = parts[0].to_i
        right = parts[1].to_i
        [left, right]
      end

      def trunk_behind_remote?(trunk, remote)
        # If the remote branch doesn't exist, treat as not behind
        return false unless remote_branch_exists?(remote, trunk)
        _ahead, behind = ahead_behind_counts(trunk, "#{remote}/#{trunk}")
        behind.positive?
      end

      def ensure_trunk_synced_before_push!(trunk, feature)
        if has_remote?("all")
          puts "Remote 'all' detected. Fetching from all remotes and enforcing strict trunk parity..."
          run_cmd!("git fetch --all")
          remotes = list_remotes
          missing_from = []
          remotes.each do |r|
            next if r == "all"
            if remote_branch_exists?(r, trunk)
              _ahead, behind = ahead_behind_counts(trunk, "#{r}/#{trunk}")
              missing_from << r if behind.positive?
            end
          end
          unless missing_from.empty?
            abort("Local #{trunk} is missing commits present on: #{missing_from.join(", ")}. Please sync trunk first.")
          end
          puts "Local #{trunk} has all commits from remotes: #{(remotes - ["all"]).join(", ")}"
          return
        end

        # Default behavior: ensure local trunk is not behind origin/trunk; if it is, rebase flows
        run_cmd!("git fetch origin #{Shellwords.escape(trunk)}")
        if trunk_behind_remote?(trunk, "origin")
          puts "Local #{trunk} is behind origin/#{trunk}. Rebasing..."
          cur = current_branch
          checkout!(trunk) unless cur == trunk
          run_cmd!("git pull --rebase origin #{Shellwords.escape(trunk)}")
          checkout!(feature) unless feature.nil? || feature == trunk
          run_cmd!("git rebase #{Shellwords.escape(trunk)}")
          puts "Rebase complete. Will push updated branch next."
        else
          puts "Local #{trunk} is up to date with origin/#{trunk}."
        end
      end

      def merge_feature_into_trunk_and_push!(trunk, feature)
        return if feature.nil? || feature == trunk
        puts "Merging #{feature} into #{trunk} (after CI success)..."
        checkout!(trunk)
        run_cmd!("git pull --rebase origin #{Shellwords.escape(trunk)}")
        run_cmd!("git merge #{Shellwords.escape(feature)}")
        run_cmd!("git push origin #{Shellwords.escape(trunk)}")
        puts "Merged #{feature} into #{trunk} and pushed. The PR (if any) should auto-close."
      end

      def export_source_date_epoch!
        epoch = Time.now.to_i
        ENV["SOURCE_DATE_EPOCH"] = epoch.to_s
        puts "Exported SOURCE_DATE_EPOCH=#{epoch}"
      end

      def ensure_signing_setup_or_skip!
        return if ENV.key?("SKIP_GEM_SIGNING")

        user = ENV.fetch("GEM_CERT_USER", ENV["USER"])
        cert_path = File.join(@root, "certs", "#{user}.pem")
        unless File.exist?(cert_path)
          abort(<<~MSG)
            Gem signing appears enabled but no public cert found at:
              #{cert_path}
            Add your public key to certs/<USER>.pem (or set GEM_CERT_USER), or set SKIP_GEM_SIGNING to build unsigned.
          MSG
        end
        puts "Found signing cert: #{cert_path}"
        puts "When prompted during build/release, enter the PEM password for ~/.ssh/gem-private_key.pem"
      end
    end
  end
end

if __FILE__ == $PROGRAM_NAME
  Kettle::Dev::ReleaseCLI.new.run
end
