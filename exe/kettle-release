#!/usr/bin/env ruby
# frozen_string_literal: true

# vim: set syntax=ruby

# kettle-release: Automate release steps from CONTRIBUTING.md
# - Runs sanity checks
# - Ensures version/changelog updated (with confirmation)
# - Commits and pushes a release prep commit
# - Ensures on trunk, up-to-date
# - Builds and releases using Bundler/Rake (reproducible by default in Bundler 2.7+)
# - Runs `bundle exec rake build` (expects PEM password unless SKIP_GEM_SIGNING)
#   - If signing not skipped and no public cert in certs/<user>.pem, aborts with guidance
# - Runs bin/gem_checksums
# - Runs `bundle exec rake release` (expects PEM password and RubyGems MFA OTP)

# Immediate, unbuffered output
$stdout.sync = true
# Depending library or project must be using bundler
require "bundler/setup"

require "kettle/dev"

# Always execute when this file is loaded (e.g., via a Bundler binstub).
# Do not guard with __FILE__ == $PROGRAM_NAME because binstubs use Kernel.load.
if ARGV.include?("-h") || ARGV.include?("--help")
  puts <<~USAGE
    Usage: kettle-release [start_step=<number>]

    Automates the release flow for a Ruby gem in the host project:

    Options:
      start_step=<number>         # skip directly to the numbered step (e.g., 10 for CI validation)
      - Runs bin/setup and bin/rake sanity checks
      - Prompts to confirm version and changelog updates
      - Commits a release prep change
      - Ensures trunk is up-to-date, pushes branch, and monitors CI (GitHub/GitLab)
      - Merges feature into trunk upon CI success
      - Builds, records checksums, and releases (requires Bundler >= 2.7.0)

    Environment:
      SKIP_GEM_SIGNING=true        # skip gem signing during build/release
      GEM_CERT_USER=<user>         # selects certs/<user>.pem for signing
      GITHUB_TOKEN / GH_TOKEN      # optional, to query GitHub Actions
      GITLAB_TOKEN / GL_TOKEN      # optional, to query GitLab pipelines
      DEBUG=true                   # print backtraces on errors
  USAGE
  exit 0
end

puts "== kettle-release v#{Kettle::Dev::Version::VERSION} =="
# Parse start_step=<n> from ARGV
start_step_arg = ARGV.find { |a| a.start_with?("start_step=") }
start_step = start_step_arg ? start_step_arg.split("=", 2)[1].to_i : 1
begin
  Kettle::Dev::ReleaseCLI.new(start_step: start_step).run
rescue LoadError => e
  warn("kettle-release: could not load dependency: #{e.message}")
  warn(e.backtrace.join("\n")) if ENV["DEBUG"]
  exit(1)
rescue SystemExit => e
  # Preserve exit status, but ensure at least a newline so shells don't show an empty line only.
  warn("kettle-release exited (status=#{e.status})") if e.status != 0
  raise
rescue StandardError => e
  warn("kettle-release: unexpected error: #{e.class}: #{e.message}")
  warn(e.backtrace.join("\n"))
  exit(1)
end
