#!/usr/bin/env ruby
# frozen_string_literal: true

# vim: set syntax=ruby

# kettle-release: Automate release steps from CONTRIBUTING.md
# - Runs sanity checks
# - Ensures version/changelog updated (with confirmation)
# - Commits and pushes a release prep commit
# - Ensures on trunk, up-to-date
# - Builds and releases using Bundler/Rake (reproducible by default in Bundler 2.7+)
# - Runs `bundle exec rake build` (expects PEM password unless SKIP_GEM_SIGNING)
#   - If signing not skipped and no public cert in certs/<user>.pem, aborts with guidance
# - Runs `bundle exec rake release` (expects PEM password and RubyGems MFA OTP)
# - Runs bin/gem_checksums (which creates the checksum commit), then pushes it
# - Optionally creates a GitHub Release when GITHUB_TOKEN is present
# - Finally pushes tags to remotes (including an 'all' aggregator if configured)

# Immediate, unbuffered output
$stdout.sync = true
$stderr.sync = true

# Do not rely on Bundler; allow running in repos that do not depend on kettle-dev
# Ensure RubyGems is available for 'require' lookups
begin
  require "rubygems"
rescue LoadError
  # Older Rubies always have rubygems; continue anyway
end

script_basename = File.basename(__FILE__)

begin
  require "kettle/dev"
  puts "== #{script_basename} v#{Kettle::Dev::Version::VERSION} =="
rescue LoadError => e
  warn("#{script_basename}: could not load dependency: #{e.class}: #{e.message}")
  warn("Hint: Ensure the host project has kettle-dev as a dependency and run bundle install.")
  exit(1)
end

# Always execute when this file is loaded (e.g., via a Bundler binstub).
# Do not guard with __FILE__ == $PROGRAM_NAME because binstubs use Kernel.load.
if ARGV.include?("-h") || ARGV.include?("--help")
  puts <<~USAGE
    Usage: kettle-release [start_step=<1-19>]

    Automates the release flow for a Ruby gem in the host project.

    Start steps (use start_step=<n> to begin at that step):
      1. Verify Bundler >= 2.7 (always runs; start at 1 to do everything)
      2. Detect version; RubyGems sanity check; confirm CHANGELOG/version; sync copyright years; update badges/headers
      3. Run bin/setup
      4. Run bin/rake (default task)
      5. Run bin/rake appraisal:update if Appraisals present
      6. Ensure git user configured; commit release prep
      7. Optional local CI with `act` (controlled by K_RELEASE_LOCAL_CI)
      8. Ensure trunk in sync across remotes; rebase feature as needed
      9. Push current branch to remotes (or 'all' remote)
     10. Monitor CI after push; abort on failures
     11. Merge feature into trunk and push
     12. Checkout trunk and pull latest
     13. Gem signing checks/guidance (skip with SKIP_GEM_SIGNING=true)
     14. Build gem (bundle exec rake build)
     15. Release gem (bundle exec rake release)
     16. Generate and validate checksums (bin/gem_checksums)
     17. Push checksum commit
     18. Create GitHub Release (requires GITHUB_TOKEN)
     19. Push tags to remotes (final)

    Options:
      start_step=<number>         # Begin at the numbered step above (e.g., 10 to resume at CI monitoring)

    Environment:
      SKIP_GEM_SIGNING=true       # Build/release unsigned; avoids PEM password prompts
      GEM_CERT_USER=<user>        # Select certs/<user>.pem for signing
      K_RELEASE_LOCAL_CI=ask|1|0  # Use 'act' locally before push; 'ask' prompts, '1' forces, default off
      K_RELEASE_LOCAL_CI_WORKFLOW # Name of workflow (without .yml) for local CI; defaults to locked_deps or first
      GITHUB_TOKEN / GH_TOKEN     # Optional; enables GitHub release creation and API queries
      GITLAB_TOKEN / GL_TOKEN     # Optional; enables GitLab API queries when applicable
      DEBUG=true                  # Print backtraces on errors

    Examples:
      kettle-release                       # full flow from the top (start_step=1)
      kettle-release start_step=10         # resume by monitoring CI for the current branch
      SKIP_GEM_SIGNING=true kettle-release start_step=14  # build+release without signing
  USAGE
  exit 0
end

# Parse start_step=<n> from ARGV
start_step_arg = ARGV.find { |a| a.start_with?("start_step=") }
start_step = start_step_arg ? start_step_arg.split("=", 2)[1].to_i : 1

begin
  Kettle::Dev::ReleaseCLI.new(start_step: start_step).run
rescue LoadError => e
  warn("#{script_basename}: could not load dependency: #{e.class}: #{e.message}")
  warn(Array(e.backtrace).join("\n")) if ENV["DEBUG"]
  exit(1)
rescue SystemExit => e
  # Preserve exit status, but ensure at least a newline so shells don't show an empty line only.
  warn("#{script_basename}: exited (status=#{e.status}, msg=#{e.message})") if e.status != 0
  raise
rescue StandardError => e
  warn("#{script_basename}: unexpected error: #{e.class}: #{e.message}")
  warn(Array(e.backtrace).join("\n"))
  exit(1)
end
