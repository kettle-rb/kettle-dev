#!/usr/bin/env ruby
# frozen_string_literal: true

# vim: set syntax=ruby

# Immediate, unbuffered output
$stdout.sync = true
# Depending library or project must be using bundler
require "bundler/setup"

# Standard library
require "erb"

# ENV variable control (set in .envrc, or .env.local)
# BRANCH_RULE_TYPE = jira, or another type of branch rule validation, or false to disable
# FOOTER_APPEND = true/false append commit message footer
BRANCH_RULES = {
  "jira" => /^(?<story_type>(hotfix)|(bug)|(feature)|(candy))\/(?<story_id>\d{8,})-.+\Z/,
}
BRANCH_RULE_TYPE = (validate = ENV.fetch("GIT_HOOK_BRANCH_VALIDATE", "false")) && !validate.casecmp?("false") && validate

# Called the "JIRA pattern", because of traditional use with JIRA.
if (branch_rule = BRANCH_RULES[BRANCH_RULE_TYPE])
  # branches should be named like:
  #	<story_type>/<story_id>-explosion-in-the-fudge-factory-spec-suite-fix
  #	where story type is one of "hotfix", "bug", "feature", "candy"
  #
  branch = %x(git branch 2> /dev/null | grep -e ^* | awk '{print $2}')
  match_data = branch.match(branch_rule)
  # NOTE: `match` will return nil if match fails, otherwise an instance of MatchData.
  # If not nil then we are assured matches for both regex capture groups
  # match_data_or_nil[:story_type] will be one of "hotfix", "bug", "feature", "candy"
  # match_data_or_nil[:story_id] will be a numeric string

  if !match_data.nil?
    commit_msg = File.read(ARGV[0])
    unless commit_msg.include?(match_data[:story_id])
      commit_msg = <<~EOS
        #{commit_msg.strip}
        [#{match_data[:story_type]}][#{match_data[:story_id]}]
      EOS
      File.open(ARGV[0], "w") do |file|
        file.print(commit_msg)
      end
    end
  end
else
  # puts "No branch rule configured (set GIT_HOOK_BRANCH_VALIDATE=jira to enforce rules for jira style branch names)"
end

class GitCommitFooter
  # Prefer project-local .git-hooks (repo root), then fallback to global ~/.git-hooks
  NAME_ASSIGNMENT_REGEX = /\bname\s*=\s*(["'])([^"']+)\1/.freeze
  FOOTER_APPEND = ENV.fetch("GIT_HOOK_FOOTER_APPEND", "false").casecmp("true").zero?
  SENTINEL = ENV["GIT_HOOK_FOOTER_SENTINEL"] # No default to avoid accidental duplicate commit of a footer via ammended commits
  raise "Set GIT_HOOK_FOOTER_SENTINEL=<footer sentinel> in .env.local (e.g., '⚡️ A message from a fellow meat-based-AI ⚡️')" if FOOTER_APPEND && (SENTINEL.nil? || SENTINEL.to_s.empty?)

  class << self
    def git_toplevel
      toplevel = nil
      begin
        # 'git rev-parse --show-toplevel' returns the repo root when run anywhere inside the repo
        out = %x(git rev-parse --show-toplevel 2>/dev/null)
        toplevel = out.strip unless out.nil? || out.empty?
      rescue StandardError
        # ignore
      end
      toplevel
    end

    def local_hooks_dir
      top = git_toplevel
      return unless top && !top.empty?
      File.join(top, ".git-hooks")
    end

    def global_hooks_dir
      File.join(ENV["HOME"], ".git-hooks")
    end

    def hooks_path_for(filename)
      local_dir = local_hooks_dir
      if local_dir
        local_path = File.join(local_dir, filename)
        return local_path if File.file?(local_path)
      end
      File.join(global_hooks_dir, filename)
    end

    def commit_goalie_path
      hooks_path_for("commit-subjects-goalie.txt")
    end

    # Determine whether the commit subject allows footer append, based on optional goalie file
    # ~/.git-hooks/commit-subjects-goalie.txt
    # - If present, only allow appending when the first line of the commit message starts with one of the non-commented prefixes
    # - If absent, disallow footer
    def goalie_allows_footer?(subject_line)
      goalie_path = commit_goalie_path
      return false unless File.file?(goalie_path)

      prefixes = File.read(goalie_path).lines.map { |l| l.strip }.reject { |l| l.empty? || l.start_with?("#") }
      # If the file exists but has no usable lines, treat as deny-all per goalie intent
      return false if prefixes.empty?

      subj = subject_line.to_s.strip
      prefixes.any? { |prefix| subj.start_with?(prefix) }
    end

    def render(*argv)
      commit_msg = File.read(argv[0])
      subject_line = commit_msg.lines.first.to_s
      if GitCommitFooter::FOOTER_APPEND && goalie_allows_footer?(subject_line)
        if commit_msg.include?(GitCommitFooter::SENTINEL)
          # This is a commit message that has already been appended
          # This will happen if the commit message is edited and re-committed
          # puts "FOOTER_APPEND is true, skipping footer append"
          exit(0)
        else
          footer_binding = GitCommitFooter.new
          # Append footer to the commit message
          File.open(argv[0], "w") do |file|
            file.print(commit_msg)
            file.print("\n")
            file.print(footer_binding.render)
          end
        end
      else
        # Skipping footer append (either FOOTER_APPEND is false, or goalie did not allow it)
      end
    end
  end

  def initialize
    @pwd = Dir.pwd
    @gemspecs = Dir["*.gemspec"]
    @spec = @gemspecs.first
    @gemspec_path = File.expand_path(@spec, @pwd)
    @gem_name = parse_gemspec_name || derive_gem_name
  end

  # Render ERB with binding variables
  def render
    ERB.new(template).result(binding)
  end

  private

  # Lightweight parse for gem name to avoid full Gem::Specification load
  def parse_gemspec_name
    begin
      content = File.read(@gemspec_path)
      # Look for name assignment patterns like:
      #   spec.name = "my_gem" OR Gem::Specification.new do |spec|; spec.name = 'my_gem'
      @name_index = content =~ NAME_ASSIGNMENT_REGEX
      if @name_index
        return $2
      end
    rescue StandardError
      # fall through
    end
    nil
  end

  # No-parse derivation of gem name, when parsing gemspec fails
  def derive_gem_name
    File.basename(@gemspec_path, ".*") if @gemspec_path
  end

  # Example
  #
  #     ⚡️ A message from a fellow meat-based-AI ⚡️
  #     I ❤️ working on <%= @gem_name %>.
  #
  # The first line is the footer sentinel (which does appear in the commit).
  # The second line, and any additional, is the main body of the footer.
  #
  # The sentinel must be set in an ENV variable (e.g., in your .env.local file):
  #
  #   export GIT_HOOK_FOOTER_SENTINEL="⚡️ A message from a fellow meat-based-AI ⚡️"
  #
  def template
    File.read(self.class.hooks_path_for("footer-template.erb.txt"))
  end
end

GitCommitFooter.render(*ARGV)
