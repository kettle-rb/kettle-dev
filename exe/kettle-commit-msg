#!/usr/bin/env ruby
# frozen_string_literal: true

# vim: set syntax=ruby

# Immediate, unbuffered output
$stdout.sync = true
# Depending library or project must be using bundler
require "bundler/setup"

# Standard library
require "erb"

require "kettle/dev"

# ENV variable control (set in .envrc, or .env.local)
# BRANCH_RULE_TYPE = jira, or another type of branch rule validation, or false to disable
# FOOTER_APPEND = true/false append commit message footer
BRANCH_RULES = {
  "jira" => /^(?<story_type>(hotfix)|(bug)|(feature)|(candy))\/(?<story_id>\d{8,})-.+\Z/,
}
BRANCH_RULE_TYPE = (validate = ENV.fetch("GIT_HOOK_BRANCH_VALIDATE", "false")) && !validate.casecmp?("false") && validate

# Called the "JIRA pattern", because of traditional use with JIRA.
if (branch_rule = BRANCH_RULES[BRANCH_RULE_TYPE])
  # branches should be named like:
  #	<story_type>/<story_id>-explosion-in-the-fudge-factory-spec-suite-fix
  #	where story type is one of "hotfix", "bug", "feature", "candy"
  #
  branch = %x(git branch 2> /dev/null | grep -e ^* | awk '{print $2}')
  match_data = branch.match(branch_rule)
  # NOTE: `match` will return nil if match fails, otherwise an instance of MatchData.
  # If not nil then we are assured matches for both regex capture groups
  # match_data_or_nil[:story_type] will be one of "hotfix", "bug", "feature", "candy"
  # match_data_or_nil[:story_id] will be a numeric string

  if !match_data.nil?
    commit_msg = File.read(ARGV[0])
    unless commit_msg.include?(match_data[:story_id])
      commit_msg = <<~EOS
        #{commit_msg.strip}
        [#{match_data[:story_type]}][#{match_data[:story_id]}]
      EOS
      File.open(ARGV[0], "w") do |file|
        file.print(commit_msg)
      end
    end
  end
else
  # puts "No branch rule configured (set GIT_HOOK_BRANCH_VALIDATE=jira to enforce rules for jira style branch names)"
end

Kettle::Dev::GitCommitFooter.render(*ARGV)
