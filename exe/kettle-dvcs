#!/usr/bin/env ruby
# frozen_string_literal: true

require "optparse"

$stdout.sync = true
$stderr.sync = true

begin
  require "kettle/dev"
rescue LoadError => e
  warn "kettle-dev library is required: #{e.message}"
  exit 1
end

module Kettle
  module Dev
    # CLI to normalize git remotes across GitHub, GitLab, and Codeberg.
    # - Defaults: origin=github, protocol=ssh, gitlab remote name=gl, codeberg remote name=cb
    # - Creates/aligns remotes and an 'all' remote that pulls only from origin, pushes to all
    class DVCSCLI
      DEFAULTS = {
        origin: "github",
        protocol: "ssh",
        gl_name: "gl",
        cb_name: "cb",
        force: false
      }.freeze

      def initialize(argv)
        @argv = argv
        @opts = DEFAULTS.dup
      end

      def run!
        parse!
        git = ensure_git_adapter!
        abort!("Working tree is not clean; commit or stash changes before proceeding") unless git.clean?

        org, repo = resolve_org_repo(git)

        names = remote_names
        urls = forge_urls(org, repo)

        # Ensure remotes exist and have desired names/urls
        ensure_remote_alignment!(git, names[:origin], urls[@opts[:origin].to_sym])
        ensure_remote_alignment!(git, names[:github], urls[:github]) if names[:github] && names[:github] != names[:origin]
        ensure_remote_alignment!(git, names[:gitlab], urls[:gitlab]) if names[:gitlab]
        ensure_remote_alignment!(git, names[:codeberg], urls[:codeberg]) if names[:codeberg]

        # Configure "all" remote: fetch only from origin, push to all three
        configure_all_remote!(git, names, urls)

        say "Remotes normalized. Origin: #{names[:origin]} (#{urls[@opts[:origin].to_sym]})"
        0
      end

      private

      def parse!
        parser = OptionParser.new do |o|
          o.banner = "Usage: kettle-dvcs [options] [ORG] [REPO]"
          o.on("--origin NAME", %w[github gitlab codeberg], "Choose origin forge (default: github)") { |v| @opts[:origin] = v }
          o.on("--protocol NAME", %w[ssh https], "Protocol (default: ssh)") { |v| @opts[:protocol] = v }
          o.on("--gitlab-name NAME", "Remote name for GitLab (default: gl)") { |v| @opts[:gl_name] = v }
          o.on("--codeberg-name NAME", "Remote name for Codeberg (default: cb)") { |v| @opts[:cb_name] = v }
          o.on("--force", "Accept defaults; non-interactive") { @opts[:force] = true }
          o.on("-h", "--help", "Show help") { puts o; exit 0 }
        end
        rest = parser.parse(@argv)
        @opts[:org] = rest[0] if rest[0]
        @opts[:repo] = rest[1] if rest[1]

        unless %w[github gitlab codeberg].include?(@opts[:origin])
          abort!("Invalid origin: #{@opts[:origin]}")
        end
      end

      def ensure_git_adapter!
        unless defined?(Kettle::Dev::GitAdapter)
          abort!("Kettle::Dev::GitAdapter is required and not available")
        end
        Kettle::Dev::GitAdapter.new
      end

      def remote_names
        {
          origin: "origin",
          github: @opts[:origin] == "github" ? "origin" : "github",
          gitlab: @opts[:origin] == "gitlab" ? "origin" : @opts[:gl_name],
          codeberg: @opts[:origin] == "codeberg" ? "origin" : @opts[:cb_name],
          all: "all"
        }
      end

      def forge_urls(org, repo)
        case @opts[:protocol]
        when "ssh"
          {
            github: "git@github.com:#{org}/#{repo}.git",
            gitlab: "git@gitlab.com:#{org}/#{repo}.git",
            codeberg: "git@codeberg.org:#{org}/#{repo}.git"
          }
        else # https
          {
            github: "https://github.com/#{org}/#{repo}.git",
            gitlab: "https://gitlab.com/#{org}/#{repo}.git",
            codeberg: "https://codeberg.org/#{org}/#{repo}.git"
          }
        end
      end

      def resolve_org_repo(git)
        org = @opts[:org]
        repo = @opts[:repo]
        if org && repo
          return [org, repo]
        end
        # Try to infer from any existing remote url
        urls = git.remotes_with_urls
        sample = urls["origin"] || urls.values.first
        if sample && sample =~ %r{[:/](?<org>[^/]+)/(?<repo>[^/]+?)(?:\.git)?$}
          org ||= Regexp.last_match(:org)
          repo ||= Regexp.last_match(:repo)
        end
        if !org || !repo
          if @opts[:force]
            abort!("ORG and REPO could not be inferred; supply them or ensure an existing remote URL")
          else
            org = prompt("Organization name", default: org)
            repo = prompt("Repository name", default: repo)
          end
        end
        [org, repo]
      end

      def prompt(label, default: nil)
        return default if @opts[:force]
        print "#{label}#{default ? " [#{default}]" : ""}: "
        ans = $stdin.gets&.strip
        ans = nil if ans == ""
        ans || default || abort!("#{label} is required")
      end

      def ensure_remote_alignment!(git, name, url)
        # Validate URL presence to avoid passing nil to Open3
        abort!("Internal error: URL for remote '#{name}' is empty") if url.nil? || url.to_s.strip.empty?
        # We need remote management capabilities via capture to avoid adding adapter methods right now.
        # Fails if GitAdapter is not present as required.
        existing = git.remotes
        if existing.include?(name)
          current = git.remote_url(name)
          if current != url
            sh_git!(git, ["remote", "set-url", name, url])
          end
        else
          # Check if any remote already points to this URL under a different name; rename it
          urls = git.remotes_with_urls
          if (pair = urls.find { |_n, u| u == url })
            old = pair[0]
            sh_git!(git, ["remote", "rename", old, name]) unless old == name
          else
            sh_git!(git, ["remote", "add", name, url])
          end
        end
      end

      def configure_all_remote!(git, names, urls)
        all = names[:all]
        # Remove existing 'all' to recreate cleanly
        if git.remotes.include?(all)
          sh_git!(git, ["remote", "remove", all])
        end
        # Create with origin fetch URL; we will add multiple pushurls
        origin_url = urls[@opts[:origin].to_sym]
        sh_git!(git, ["remote", "add", all, origin_url])
        # Ensure fetch only from origin (set fetch refspec to match origin's default)
        # We'll reset fetch to +refs/heads/*:refs/remotes/all/* from origin remote
        # Simpler: disable fetch by clearing fetch then add one matching origin
        sh_git!(git, ["config", "--unset-all", "remote.#{all}.fetch"]) # ignore failure
        # Emulate origin default fetch
        sh_git!(git, ["config", "--add", "remote.#{all}.fetch", "+refs/heads/*:refs/remotes/#{all}/*"])
        # Configure push to all forges
        %i[github gitlab codeberg].each do |forge|
          sh_git!(git, ["config", "--add", "remote.#{all}.pushurl", forge_urls_entry(forge, urls)])
        end
      end

      def forge_urls_entry(forge, urls)
        urls[forge]
      end

      def sh_git!(git, args)
        # Ensure no nil sneaks into the argv to Open3 (TypeError avoidance)
        if args.any? { |a| a.nil? || (a.respond_to?(:strip) && a.strip.empty?) }
          abort!("Internal error: Attempted to run 'git #{args.inspect}' with an empty argument")
        end
        out, ok = git.capture(args)
        unless ok
          abort!("git #{args.join(" ")} failed: #{out}")
        end
        out
      end

      def say(msg)
        puts msg
      end

      def abort!(msg)
        warn msg
        exit 1
      end
    end
  end
end

if $PROGRAM_NAME == __FILE__
  exit Kettle::Dev::DVCSCLI.new(ARGV).run!
end
